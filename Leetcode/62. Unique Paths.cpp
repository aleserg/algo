class Solution {
public:
    /* r - робот. Ответ в правом нижнем углу. Можно создать матрицу (m + 1) * ( n + 1 ) и решить задачу, используя следующее утверждение: 
      робот может ходить вниз и вправо. Соответственно в каждой точке матрицы он может оказаться, либо придя сверху, либо слева. Можем сложить значения в этих ячейках и получить количество уникальных путей.
       r 1 1  1  1  1  1
       1 2 3  4  5  6  7
       1 3 6 10 15 21 28
       идея данного решения в том, что нам не нужна вся матрица. Нам нужен только 1 столбец:
       Начальное значение:
       0 - фейк ячейка, чтобы не получать выход за границы
       1 - начальное положение. Тут стоит робот. Он добрался сюда единственным возможным образом
       0
       0       
       Рассчитаем первую итерацию:
       0       0
       1   ->  1 ( сверху 0, предыдущее значение этой ячейки - 1 )
       1       2 ( сверху 1, предыдущее значение этой ячейки - 1 )
       1       3 ( сверху 2, предыдущее значение этой ячейки - 1)
       Если не понятно, то можно сначала создать 2 столбца ( текущий и предыдущий ) и свапать их каждый цикл. Потом станет понятно, что и в одном столбце информации достаточно для расчета
     */
    int uniquePaths(int m, int n) 
    {
        std::vector<int> curCol(m+1);
        curCol[ 1 ] = 1;
        while ( n )
        {
            for ( int i = 1; i < curCol.size(); i++ )
                curCol[i] = curCol[i-1] + curCol[i];
            n--;
        }
        return curCol[m];
    }
};
